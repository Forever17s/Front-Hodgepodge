<div align="center">

## 前端进阶 - 丁篇

  <img src="./../resource/interview_header.png" width="500" />

</div>

---

#### 浏览器如何进行垃圾回收

##### 1.什么是垃圾?

- 不再需要，即为垃圾
- 全局变量随时可能用到，所以一定不是垃圾

##### 2.如何捡垃圾?（遍历算法）

- 标记空间中『 可达 』值。
  - 从根节点（`Root`）出发，遍历所有的对象。
  - 可以遍历到的对象，是可达的（`reachable`）。
  - 没有被遍历到的对象，不可达的（`unreachable`）
- 回收「不可达」的值所占据的内存。
- 做内存整理。

##### 3.什么时候捡垃圾?

前端有其特殊性，垃圾回收的时候，会暂停 `JavaScript` 脚本。

- `分代收集`：浏览器将数据分为两种，一种是临时对象（`新生代`），一种是长久对象（`老生代`）。副垃圾回收器、主垃圾回收器，分别负责新生代、老生代的垃圾回收。
- `增量收集`：如果脚本中有许多对象，引擎一次性遍历整个对象，会造成一个长时间暂停。所以引擎将垃圾收集工作分成更小的块，每次处理一部分，多次处理。这样就解决了长时间停顿的问题。
- `闲时收集`：垃圾收集器只会在 CPU 空闲时尝试运行，以减少可能对代码执行的影响。

#### 浏览器中不同类型变量的内存都是何时释放

##### 1.引用类型

在没有引用之后，通过 V8 自动回收。

##### 2.值类型

- 闭包的情况下，要等闭包没有引用才会被 V8 回收。
- 非闭包的情况下，等待 V8 的新生代切换的时候回收。

> 新生代的垃圾回收，通常只支持 1~8 M 的容量。等对象区域快满的时候，会执行一次垃圾清理。

#### 如何避免内存泄露

> 内存泄露是指你访问不到的变量，依然占居着内存空间，不能被再次利用起来。

###### 以 Vue 为例，通常有这些情况会导致内存泄露：

- 监听在 `window`、`body` 等事件没有解绑
- 绑在 `EventBus` 的事件没有解绑
- `Vuex` 的 `$store`，`watch` 了之后没有 `unwatch`
- 使用第三方库创建，没有调用正确的销毁函数

###### 解决办法：beforeDestroy 中及时销毁

- 绑定了 DOM/BOM 对象中的事件 `addEventListener`、`removeEventListener。`
- 观察者模式 `$on`，`$off` 处理。
- 如果组件中使用了定时器，应销毁处理。
- 如果在 `mounted`、`created` 钩子中使用了第三方库初始化，对应的销毁。
- 使用弱引用 `weakMap`、`weakSet`。

#### 闭包的定义

通俗解释：当一个内部函数被调用,就会形成闭包,闭包就是能够读取其他函数内部变量的函数
词法分析：当前函数和它周围环境（词法环境）的引用被绑定到一起。

#### 闭包会不会导致内存泄露

> 闭包会导致内存泄露吗？正确的答案是 **不会**。

内存泄露是指访问不到的变量，依然占居着内存空间，不能被再次利用起来。
闭包里面的变量就是我们需要的变量，不能说是内存泄露。

> **闭包会导致内存泄露** 这个误解是如何来的？因为 `IE` 有 `bug`，`IE` 在我们使用完闭包之后，依然回收不了闭包里面引用的变量。这是 IE 的问题，不是闭包的问题

#### weakMap weakSet 和 Map Set 的区别

在 `ES6` 中新增了两个数据结构 `WeakMap`、`WeakSet`，就是为了解决内存泄漏的问题。
它的键名所引用的对象都是`弱引用`，就是垃圾回收机制遍历的时候不考虑该引用。
只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。
也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。

#### 手写 Array.flat

```javascript
Array.prototype.flat = function () {
  let arr = [];
  this.forEach((item) => {
    if (Array.isArray(item)) arr = arr.concat(item.flat());
    else arr.push(item);
  });

  return arr;
};

[[2], [[2, 3], [2]], 3, 4].flat();
// [2, 2, 3, 2, 3, 4]
```

#### import 最后被解析成了什么

##### import 经过 `webpack` 编译打包后最终变成了什么？

> `import` 经过 `webpack` 打包以后变成一些 `Map` `对象，key` 为模块路径，`value` 为模块的可执行函数；

##### 在浏览器中是怎么运行的？

> 代码加载到浏览器以后从入口模块开始执行，其中执行的过程中，最重要的就是 `webpack` 定义的`__webpack_require__`函数，负责实际的模块加载并执行这些模块内容，返回执行结果，其实就是读取 `Map` 对象，然后执行相应的函数；

##### 说说 import 异步方法

> `import('xxModule')`它会单独打成一个包，采用动态加载的方式，具体过程：当用户触发其加载的动作时，会动态的在 `head` 标签中创建一个 `script` 标签，然后发送一个 `http` 请求，加载模块，模块加载完成以后自动执行其中的代码，主要的工作有两个，更改缓存中模块的状态，另一个就是执行模块代码。

#### 函数式编程

命令式编程中 `典型` 的方法和过程都深深地根植于它们所在的环境中，通过状态、依赖和有效作用达成；纯函数与此相反，它与环境无关，只要我们愿意，可以在任何地方运行它

> 面向对象语言的问题是，它们永远都要随身携带那些隐式的环境。你只需要一个香蕉，但却得到一个拿着香蕉的大猩猩...以及整个丛林

##### 函数与其他数据类型一样，处于平等地位

可作为变量一样被传递、返回或者在函数中嵌套函数。可作为参数。使用总有返回值的表达式而不是语句

##### 函数应该纯天然，无副作用

副作用是指，函数内部与外部互动，产生运算以外的其他结果。 例如在函数调用的过程中，利用并修改到了外部的变量，那么就是一个有副作用的函数。副作用包含：

- 改变了任何外部变量或对象属性（例如，全局变量，或者一个在父级函数作用域链上的变量）
- 写日志
- 在屏幕输出
- 写文件
- 发网络请求
- 触发任何外部进程
- 调用另一个有副作用的函数

##### 引用透明

纯函数的运行不应该依赖于外部变量或状态，只依赖于输入的参数。对于相同的输入参数，返回的结果一定相同。

##### 不可变量

如果要改变变量，则需要把数据 deep copy 出去进行修改

###### 题外话

_`react` 在 `16.8` 引入了 `hooks` 目的就是为了拥抱`函数式编程`，让函数式组件有了状态和其他 `react` 特性。_

#### PWA 简介

`渐进式网络应用`（PWA）是谷歌在 2015 年底提出的概念。基本上算是 `web` 应用程序，但在外观和感觉上与原生 `app` 类似。支持 `PWA` 的网站可以提供脱机工作、推送通知和设备硬件访问等功能。具有以下优点：

**1.更小更快**：渐进式的 web 应用程序比原生应用程序小得多。他们甚至不需要安装。这是他们没有浪费磁盘空间和加载速度非常快。
**2.响应式界面**：PWA 支持的网页能够自动适应各种屏幕大小。它可以是手机、平板、台式机或笔记本。
**3.无需更新**：大多数移动应用程序需要每周定期更新。与普通网站一样，每当用户交互发生且不需要应用程序或游戏商店批准时，PWA 总是加载最新更新版本。
**4.高性价比**：原生移动应用需要分别为 Android 和 iOS 设备开发，开发成本非常高。另一方面，PWAs 有着相同的功能，但只是先前价格的一小部分，开发成本低。
**5.SEO 优势**：搜索引擎可以发现 PWAs，并且加载速度非常快。就像其他网站一样，它们的链接也可以共享。提供良好的用户体验和结果，在 SEO 排名提高。
**6.脱机功能**：由于 service worker API 的支持，可以在脱机或低 internet 连接中访问 PWAs。
**7.安全性**：PWAs 通过 HTTPS 连接传递，并在每次交互中保护用户数据。
**8.推送通知**：通过推送通知的支持，PWAs 轻松地与用户进行交互，提供非常棒的用户体验。
**9.绕过应用商店**：原生 app 如果需要任何新的更新,需要应用商店几天的审批，且有被拒绝或禁止的可能性,对于这方面来说，PWAs 有它独特的优势，不需要 App Store 支持。更新版本可以直接从 web 服务器加载，无需 App Store 批准。
**10.零安装**：在浏览过程中，PWA 会在手机和平板电脑上有自己的图标，就像移动应用程序一样，但不需要经过冗长的安装过程。

#### web worker 简介

Javascript 是运行在单线程环境中，无法同时运行多个脚本，当运行代码被阻塞时会出现交互卡顿的现象，如果将这段代码交给 Web Worker 去运行，浏览器会在后台启动一个独立的 worker 线程来专门负责这段代码的运行。

##### 强大的计算能力

可以加载一个 `JS` 进行大量的复杂计算而不挂起主进程，并通过 `postMessage`，`onmessage` 进行通信，解决了大量计算对 `UI` 渲染的阻塞问题。

##### 典型应用场景

**1.数学运算**：`Web Worker` 最简单的应用就是用来做后台计算，对 `CPU` 密集型的场景再适合不过了。
**2.图像处理**：通过使用从`<canvas>`中获取的数据，可以把图像分割成几个不同的区域并且把它们推送给并行的不同 `Workers` 来做计算，对图像进行像素级的处理，再把处理完成的图像数据返回给主页面。
**3.大数据的处理**：目前 `mvvm` 框架越来越普及，基于数据驱动的开发模式也越愈发流行，未来大数据的处理也可能转向到前台，这时，将大数据的处理交给在 `Web Worker` 也是上上之策了吧。
